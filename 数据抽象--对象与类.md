# 数据抽象--对象与类

## 	1. 类

类描述了一组具有相同特征的对象，定义类时需要显式地定义他的操作集，被称为一种抽象数据类型（只需要直到类提供的操作，而不需知道类数据的具体表示）

* 数据成员

  数据成员是指类的对象所包含的数据，类定义中描述的数据成员属于该类的对象，在创建对象之前，==类中说明的数据成员不占内存空间，故在描述数据成员时一般不能赋初值。==

  数据成员可以是任意的数据类型，但是在声明一个数据成员的类型时，如果未见到相应的类型定义或相应的类型定义未定义完，则该数据成员==一般只能是这些类型的指针或引用类型==

  ```c++
  class A;//A是在程序其他地方定义的类，此处是声明
  class B{
      A a;//error, 未见A定义
      A *p;//OK 
      A &aa;//ok
  }
  ```

* 成员函数

  成员函数描述了对类中定义的数据成员所能实施的操作，在类定义内外均可。==但在类外实现成员函数时，应在类定义中给出成员函数的声明，在类外定义成员函数，在返回类型和函数名之间加上::，采用类外方式定义成员函数，在进行类的声明时，成员函数原型中的形参名可以省略，只声明各个形参的类型，定义时成员函数的返回类型、函数名称、参数表必须与成员函数原型的声明完全一致，且必须指出每个参数的名字==

  ```c++
  class Date
  {public:
   	void set(int y,int m,int d);
   	bool is_leap_year();
   	void print();
   private:
   	int year,month,day;
  }
  void Date::set(int y,int m,int d)
  {
  	year=y;
      month=m;
      day=d;
  }
  void Date::is_leap_year(int y,int m,int d)
  {
      return(year%4==0 && year % 100!=0)||(year%400==0);
  }
  void Date::print()
  {
  	cout<<year<<"."<<month<<"."<<day;
  }
  ```

* 成员的访问控制——信息隐藏

  成员访问修饰符：

  1. public：成员的访问不受限制，在程序中的任何地方都可以访问一个类的public成员
  2. private：成员只能在本类和友元中访问
  3. protected：成员只能在本类、友元和派生类中访问

  ==关于成员访问修饰符的说明==：

  * 三种成员访问修饰符在类声明中没有先后次序之分
  * 三种成员修饰符出现的次数没有限制
  * 出于信息隐藏的目的，通常将数据成员设置为private，将需要让类外部函数访问的成员函数设置为public权限。
  * 类与结构的区别:==类定义中默认情况下成员是private==,struct默认情况下成员是public，常用struct设计只有数据成员的结构，用class设计既有数据成员，也有成员函数的类。
  
  对类成员的访问除了要受到类成员访问控制的限制外，还要受到标识符作用域的限制。类定义构成一个作用域--类作用域，在其定义得标识符局部于类定义，他们只能在类的内部访问，在类的外部使用类定义的标识符时，需通过对象名受限或类名受限。另外，在类中使用与成员标识符同名的全局标识符时，需要在全局标识符前面加上全局域解析符。
  
  类的声明或定义只是增加了一种自定义数据类型，此时类内部的数据成员并没有获取到相应的内存空间，==只有在用类定义对象时，才会为数据成员分配空间，在这个时间点上才会用相应的初始值初始化数据成员。==
  
  ## 2.对象
  
  * 创建对象
  
    * 直接操作
  
      ```C++
      class A
      {
      	public:
      		void f();
          	void g();
          private:
          	int x,y;
          
      }
      A a1;
      A a2[100];
      ```
  
      如果变量的类型为类，则称该变量为对象，用变量名来标识相应的对象。
  
    * 间接方式
  
      在程序运行时刻，通过new操作创建的对象（动态对象），其内存空间在程序的堆区中分配，用指针变量标识，delete操作撤销。动态对象一般不采用malloc和free
  
      ```c++
      A *p;
      p=new A;
      delete p; 
      
      //动态对象数组的创建与撤销
      A *p;
      p=new A[100];
      ......
      delete []p;
      ```
  
  * 对象的操作
  
    要对一个对象进行操作，一般需要通过对象类的==public==成员实现。==对于非动态对象，采用<对象>.<类成员>；对于动态变量，<对象指针>-><类成员>或（*<对象指针>）.<类成员>形式==
  
    ```c++
    class A
    {
        int x;
        public:
        	void f();
        	void g();
    }
    int main()
    {
        A a;//创建A类的一个局部变量a
        a.f();
        a.g();
        A *p=new A;
        p->f();
        *p.g();
        delete p;
        return 0; 
    }
    ```
  
     对象间赋值操作的含义是，吧赋值操作符右边对象的数据成员的值分别赋给左边对象的数据成员
  
  * this指针
  
    类的每个对象都有自己的数据成员，有多少个对象，就有多少份数据成员的备份（静态成员）。然而类的成员函数只有一份备份，不论有多少个对象，都共用这份成员函数。成员函数通过this指针哪个对象在调用它，它应该处理哪个对象的数据成员。
  
    ```c++
    class A
    {
    	...
    }
    A a,b
    ```
    
    ​	对于上述创建的对象a,b他们分别拥有一块内存空间，该内存空间用于存储他们各自的数据成员a.x,a.y,a.z和b.x,b.y,b.z。而类定义中成员对该类的所有对象则只有一个拷贝。==每一个成员函数一般都有一个隐藏的形参this，==
    
    ```c++
    class X{}；
    X * this;
    ```
    
    this是成员函数中，指向调用该函数的对象自身（即成员函数所属的类对象的首地址）的隐含指针，代表对象自身的地址。当通过对象来调用类的成员函数时，编译程序会把相应的对象的地址作为实参传给成员函数的隐藏的形参this。编译程序的编译过程如下
    
    ```c++
    void g(A *const this, int i){this ->x=i;}
    ```
    
    函数通过this即可知道对哪一个对象进行访问。
    
    ![577999c7c99c934a09b5b1675c69a205.png](https://p.ananas.chaoxing.com/star3/origin/577999c7c99c934a09b5b1675c69a205.png)
    
    通常情况下，==在成员函数中访问类的成员时==，this ->可以省略不写，但==如果在成员函数中要把this所指向的对象作为整体进行操作，必须显式地使用this指针==
    
    ```c++
    void func(A *p)
    {
    ......
    }
    class A
    {
    public:
    	int x;
    	void g(int i){x=i;func(this);}
    	...
    private:
    	int x,y,z;
    A a,b;
    a.g(1);
    b.g(1);
    }
    ```
    
    *解释一下内联函数*
    
    函数调用是有时间和空间开销的。程序在执行一个函数之前需要做一些准备工作，要将实参、局部变量、返回地址以及若干寄存器都压入栈中，然后才能执行函数体中的代码；函数体中的代码执行完毕后还要清理现场，将之前压入栈中的数据都出栈，才能接着执行函数调用位置以后的代码。
    
    如果函数体代码比较多，需要较长的执行时间，那么函数调用机制占用的时间可以忽略；如果函数只有一两条语句，那么大部分的时间都会花费在函数调用机制上，这种时间开销就就不容忽视。
    
    为了消除函数调用的时空开销，C++ 提供一种提高效率的方法，即在编译时将函数调用处用函数体替换，类似于C语言中的宏展开。这种在函数调用处直接嵌入函数体的函数称为内联函数（Inline Function），又称内嵌函数或者内置函数。
    
    ```c++
    #include <iostream>
    using namespace std;
     
    //内联函数，交换两个数的值
    inline void swap(int *a, int *b)
    {
        int temp;
        temp = *a;
        *a = *b;
        *b = temp;
    }
     
    int main()
    {
        int m, n;
        cin>>m>>n;
        cout<<m<<", "<<n<<endl;
        swap(&m, &n);
        cout<<m<<", "<<n<<endl;
     
        return 0;
    }
     
    //运行结果：
    //45 99
    //45, 99
    //99, 45
    ```
    
    注意，要在函数定义处添加 inline 关键字，在函数声明处添加 inline 关键字虽然没有错，但这种做法是无效的，编译器会忽略函数声明处的 inline 关键字。==当编译器遇到函数调用swap(&m, &n)时，会用 swap() 函数的代码替换swap(&m, &n)，同时用实参代替形参.==
  
  * 对象数组
  
    对象数组就是用类定义的数组，它的每个元素都是对象。
  
    ```c++
    X a[10];
    ```
  
    定义一个对象数组时，系统为对象数组的每一个数组元素调用一次构造函数，来初始化每一个数组元素。它创建了一个对象数组a，有10个数组元素，每个数组元素a[i]都是一个对象，所以，需要10次调用构造函数。
  
     ==如果一个类只有需要参数的构造函数（不包括全部参数都有默认值的情况），就不能定义其对象数组。要定义对象数组的类必须有不需要参数的构造函数==，包括以下几种情况：
  
    * **没有构造函数**；没有定义任何构造函数的类可以定义对象数组，因为C++会为这种类产生一个默认构造函数。
  
    * **有构造函数**，但要有一个构造函数不带参数；
  
    *  **有构造函数**，但要有一个构造函数具有的参数全是缺省参数。
  
  * 对象指针
  
    * 定义对象的指针，用指针指向类对象。用法：
  
      ```c++
      类名* 对象指针名
      Time  t1;
      Time  *p=&t1; 
      ```
  
    * 通过指针变量可以间接访问对象成员
  
      ```c++
      (*指针变量).数据成员名； //访问数据成员
      (*指针变量).成员函数名(参数表)；//访问成员函数
      ```

## 3.对象的初始化和消亡前处理

* 构造函数

  用于初始化对象的数据成员，但由于数据成员一般为私有，不能直接赋值，故在对象类中提供一个实现对象初始化的普通成员函数，创建对象后通过调用该函数来初始化对象，但普通成员函数会带来不便和不安全的因素，故一般用类的构造函数解决对象初始化问题。

  * 构造函数的定义

    ==在对象类中定义或声明的与类同名，无返回值类型的成员函数，在创建对象时被自动调用==。对构造函数的调用是对象创建过程的一部分，且对象创建之后不能再调用构造函数。

    ```C++
    class A
    {
        int x,y;
     public:
        A();//默认构造函数
        {
            x=y=0;
        }
        A(int x1)
        {
            x=x1,y=0;
        }
      A(int x1,int y1)
      {
          x=x1;y=y1;
      }
    }
    ```

  * 构造函数调用的选择

    ```c++
    class A
    {
        ......
     public:
        A();//默认构造函数
        A(int i);
        A(char *p);
        
    }
    A a1;//调用默认构造函数
    A a2(1);
    A a3("abcd")
    A a[4];//调用对象a[0],a[1],a[2],a[3]的默认构造函数
    A b[5]={A(),A(1),A("abcd"),2,"xyz"};
    A *p1=new A;
    A *p2=new A(2);
    A *p3=new A("xyz");
    A *p4=new A[20];//创建动态对象数组时只能调用各对象的默认构造函数
    ```

    构造函数使用注意事项:

    * 构造函数不能有返回类型，即使void也不行。

    * 构造函数由系统自动调用，不能在程序中显式调用构造函数。
    * 构造函数的调用时机是定义对象之后的第一时间，即构造函数是对象的第一个被调用函数。 
    * ==定义对象数组或用new创建动态对象时，也要调用构造函数。但定义数组对象时，必须有不需要参数的构造函数 。==
    * 构造函数通常应定义为公有成员，因为在程序中定义对象时，要涉及构造函数的调用，尽管是由编译系统进行的隐式调用，但也是在类外进行的成员函数访问。

  * 默认构造函数

    * 系统默认构造函数：C++规定，每个类必须有构造函数，如果一个类没有定义任何构造函数，在需要时编译器将会为它生成一个默认构造函数。 ==在用默认构造函数创建对象时，如果创建的是全局对象或静态对象，则对象所有数据成员初始化为0；如果创建的是局部对象，即不进行对象数据成员的初始化。==一旦定义了任何形式的构造函数，系统就不再产生默认构造函数。

    * 重定义默认构造函数：C++允许显式定义无参数的构造函数，这样就能通过它为对象的数据成员提供初始值。
    
      ```c++
      class X {
          X()=default;       //      11C++
          X(……){}          //需要参数的构造函数       
           ……
          }
      ```
    
    * 带默认参数值的构造函数与无参构造函数的冲突问题
    
      ```c++
      class X{
         public:
             X(){};
             X(int i=0){x=i;};
         private:
             int x;      
             };
       void main(){
            X one(12);           //L1 调用X:X(int i=0)
             X two;                //L2 调用X:X()还是X:X(int i=0)？
             X * pt = new X;  //L3 调用X:X()还是X:X(int i=0)？
       }                             
      ```
    
      如果显式定义了无参数的默认构造函数，又定义了全部参数都有默认值的构造函数，就容易在定义对象时产生二义性。==主函数的语句L1会调用构造函数X::X(int i=0)初始化对象one；但L2和L3的定义则会发生冲突，因为X::X(int i=0)和X::X()都可以定义对象two和pt所指向的对象，系统不能确定调用哪个构造函数，因此产生错误。==
    
  * 重载构造函数

    

  * 成员初始化表

    对于常量数据成员和引用类型数据成员，不能再说明他们时初始化，也不能采用赋值操作对他们进行初始化，则可以在定义构造函数时，在函数头和函数体之间加入一个对数据成员进行初始化的表。

    ```c++
    class A
    {
        int x;
        const int y;
        int & z;
      public:
        A():z(x),y(1)//成员初始化表
        {
            x=0;//对x的初始化页可以放在成员初始化表中
        }
    };
    ```

    在成员初始化表中，成员初始化的书写次序并不决定他们的初始化次序，数据成员的初始化次序由他们在类定义中的说明次序决定。当类中由常量数据或引用类型数据成员时，一定要定义构造函数，否则这个类不能用于创建对象。

    成员初始化表使用注意事项:
    
    * 构造函数初始化列表中的成员初始化次序与它们在类中的声明次序相同，与初始列表中的次序无关。如对例中的类而言，下面3个构造函数是完全相同的。
    
      ```c++
      Tdate::Tdate(int m,int d,int y):month(m),day(d),year(y){}
      Tdate::Tdate(int m,int d,int y):year(y),month(m),day(d){}
      Tdate::Tdate(int m,int d,int y):day(d),year(y),month(m){}
      ```
    
      尽管三个构造函数初始化列表中的month、day和year的次序不同，但它们都是按照month→day→year的次序初始化的，这个次序是其在Tdate中的声明次序。 
    
    * 构造函数初始化列表的执行时间。如果数据成员有类内初始值，则执行次序为：**类内初始值→构造函数初始化列表→构造函数体**
    
    * 常量成员，引用成员，类对象成员，派生类构造函数对基类构造函数的调用必须采用**初始化列表进行初始化。**

* 析构函数

  ```c++
  class A
  {
      int x;
    public:
      A();
      ~A();//析构函数
  }
  ```

* 成员对象的初始化

  对于类的数据成员，其类型可以是另一个类，这样就使得一个对象可以包含另一个对象——成员对象。对==成员对象==的初始化是由==成员对象类的构造函数==来实现的。==如需要调用成员对象类的非默认构造函数来对成员对象初始化，则要在包含成员对象的类的构造函数成员初始化表中显式地指出==。编译程序把成员初始化表中对成员对象的初始化描述编译成对成员对象构造函数的调用指令。在创建含有成员对象的类的对象时，首先调用本身类的构造函数，但在进入本身类的构造函数的函数体之前，将会先调用成员对象类的构造函数，然后再执行本身类的构造函数的函数体。即使成员初始化表为空，只要类中有成员对象，编译程序就会生成对应成员对象构造函数的调用指令，只不过他是调用成员对象的默认构造函数。

  ```c++
  class A
  {
      int m;
    public:
  	A(){m=0;}
      A(int m1){m=m1;}
      ......
  
  };
  class B
  {
      int n;
      A a;
    public:
      B(){n=0;}
      B(int n1){n=n1;}
      B(int n1,int m1):a(m1){n=n1;}//b3.a的成员m将被初始化为2
      ......
  };
  B b1,b2(1),b3(1,2);
  ```

  当一个对象包含多个成员对象时，对成员对象构造函数的调用次序取决于成员对象在类中的说明次序，析构函数的调用次序正好相反。

* 拷贝构造函数

  在创建一个对象时，用另一个同类的对象对其进行初始化。

  ```c++
  class A
  {
      ......
   public:
      A();
      A(const A& a);//拷贝构造函数<类名>(const<类名>&)
  }
  ```

  调用拷贝构造函数的情况：

  1. 定义对象时
  
  2. 把对象作为值参数传递给函数
  
  3. 把对象作为值返回
  
     ```c++
     //定义对象时
     A a1;
     A a2(a1)//调用拷贝构造函数
     
     //把对象作为值参数传递给函数
     void f(A x):
     A a;
     f(a);
     
     //把对象作为值返回时
     A f()
     {
         A a;
         ......
         return a;//创建一个A类的临时对象，并调用拷贝构造函数用对象a对其初始化
     }
     ......
     A a1;
     a1=f();//把f返回的临时对象赋值给对象a1
     ```
  
     如果在一个类定义中没有定义拷贝构造函数，则编译程序将会提供一个隐式的拷贝构造函数，该拷贝构造函数的行为是：逐个成员拷贝初始化，即对于普通数据成员，采用常规的成员初始化操作，==对于成员对象==，则调用成员对象类的拷贝构造函数来实现成员对象的初始化。
  
     ```c++
     class A
     {
         int x,y;
       public:
         A(){x=y=0;}
         ......
     };
     class B
     {
         int z;
         A a;
       public:
         B(){z=0;}
         ....//其中没有定义拷贝构造函数
     };
     .....
     B b1;//b1.z,b1.a.x以及b1.a.y均为0，
     B b2(b1);//把b2.z初始化成b1.z,调用A的拷贝构造函数用用b1z.对b2.z初始化；如果A没有定义拷贝构造函数，则调用A的隐式拷贝构造函数；把b2.a.x和b2.a,y分别初始化成b1.a.x和b1.a.y;否则，有A的自定义拷贝构造函数决定如何对b2.a.x和b2.a,y初始化
     ```
  
     一般情况下，编译程序提供的隐式拷贝构造函数的行为足以满足要求，类中不需要显式定义拷贝构造函数。但是有些情况下若不自定义拷贝构造函数，则会产生设计者未意识到的严重程序错误
  
     ```c++
     class A
     {
         int x,y;
         char *p;
       public:
         A(char *str)
         {
             x=0;
             y=0;
             p=new char(strlen(str)+1);
             strcpy(p,str);
         }
         ~A(){ delete []p;p=NULL;}
         ......//没有定义拷贝构造函数
     }
     A a1("abcd");
     A a2(a1);//调用隐式拷贝构造函数，用a1对a2进行初始化
     ```
  
     系统提供的隐式拷贝构造函数将会使得a1和a2的成员指针p指向同一块内存区域：
  
     ![image-20221030235535165](C:\Users\GrinchWu\AppData\Roaming\Typora\typora-user-images\image-20221030235535165.png)
  
     它所带来的问题是：
  
     1. 如果对对象a1操作之后修改了这块空间的内容，a2将会受到影响
     2. 当对象a1和a2消亡时，将会分别去调用他们的析构函数，使得一块内存区域被归还两次
     3. 当对象a1和a2有一个消亡，另一个还未消亡时，会出现使用已归还的空间错误
  
     ```c++
     A::A(const A& a)
     {
         x=a.x;
         y=a.y;
         p=new char[strlen(a.p+1)];//另外申请一块空间供新创建的对象使用
         strcpy(p,a.p)//把a.p指向的内容复制到新对象的p所指向的空间中
     }
     ```
  
     需要注意的是。当类定义中包含成员对象时，系统提供的隐式拷贝构造函数会调用==成员对象的拷贝构造函数==，但自定义的拷贝构造函数则会默认调用成员对象的==默认构造函数==，而不是调用成员对象的拷贝构造函数。
  
     为保证b2与b1一致，则应在自定义拷贝构造函数的成员初始化表中显式地指出调用成员对象类的拷贝构造函数：
  
     ```c++
     B(const B& b): a(b.a){z=b.z;}
     ```
  
     当用一个临时对象对另一个对象进行初始化时，很多编译器对拷贝构造过程进行优化
  
     ```c++
     class A
     {
         int m;
       public:
         A(int i){m=i;}
         A(const A& a){m=a.m;}
         ......
     }
     A f(A x)
     {
         ......
         return A(1);//优化，不在创建返回值对象，直接返回临时对象A(1)
     }
     int main()
     {
         ......
         ...f(A(0))...//优化，不在创建函数f的形参对象x，直接把临时对象A(0)作为x
             .....
     }
     ```
  
     在不优化的情况下，==在函数main中调用函数f时==，先创建一个临时对象A(0)，再创建一个形参对象x，调用拷贝构造函数用对象A(0)对其初始化；==在函数f返回时==，先创建一个临时对象A(1)，再创建一个返回值对象，调用拷贝构造函数用A(1)对其初始化。
  
     拷贝构造函数的说明:
  
     * 拷贝构造函数与一般构造函数相同，与类同名，没有返回类型，可以重载。
     * 拷贝构造函数的参数常常是const类型的本类对象的引用。
     * 在多数情况下，默认拷贝构造函数能够完成对象的复制创建工作，==但当类具有指针类型的数据成员时，默认复制构造函数就可能产生指针悬挂问题，需要提供显式的拷贝构造函数。==
     * 对拷贝构造函数的调用常在类的外部进行，应该将它指定为类的公有成员。
  
     拷贝构造函数的应用举例：
  
     * 当用类的一个对象去初始化该类的另一个对象时系统自动调用它实现拷贝赋值。
  
       ```c++
       void main() {
           Point A(1,2);
           Point B(A);
           Point C=A;
           Point D;
           D=A;
       }
       ```
  
       B和Ｃ都是用已存在的对象Ａ创建并初始化新对象，都会调用复制构造函数。==这两条语句先调用无参构造函数建立Ｄ，然后再用赋值语句将Ａ赋值给Ｄ，并不会调用复制构造函数。==
  
     * 若函数的形参为类对象，调用函数时，实参赋值给形参，系统自动调用复制构造函数。
  
       ```c++
       void fun1(Point p) {
           cout<<p.getX()<<endl;
       }
       
       void main() {
           Point A(1,2);
           fun1(A);//调用复制构造函数
       }
       ```
  
       
  
     * 当函数的返回值是类对象时，系统自动调用复制构造函数。
  
       ```c++
        Point fun2() {
            Point A(1,2);
            return A;
       }
        void main() {
            Point B=fun2(); 
        }
       ```
  
       

## 5.类作为模块

在面向对象程序中，可以把一个类当作一个模块，也可以把多个具有继承关系或聚集关系的类作为一个模块。一个c++模块一般由两个源文件构成，一个是.h文件，一个是.cpp文件，.h文件中存放的是类的定义，.cpp文件中存放的则是类外定义的成员函数。

**类的接口：**即指类的声明，常保存为与类同名的.h头文件

**实现：**是指类的成员函数的定义。放在一个与类同名的源程序中（即扩展名为.cpp的文件）。

## 6.对象与类的进一步讨论

### 1.常成员函数

成员函数一般可分为两类：==修改对象状态的成员函数和获取对象状态的成员函数==。从概念上说，一个成员函数只要不修改对象数据成员的值，他就是一个获取对象状态的成员函数，但常由于疏忽无意间修改其值，故在定义一个成员函数时，加上一个const说明，==表示它是一个获取对象状态的常成员函数==

```c++
class A
{
    ......
    void f() const{......}
};
```

成员函数加上const修饰符可有两个作用；

* 在const成员函数定义的地方，告诉编译程序该成员函数不应该改变对象数据成员的值

  ```c++
  class A
  {
      int x,y;
    public:
      void f() const{......}
      void g(){......}
  };
  const A a;
  ......
  a.f();//OK
  a.g();//ERROR,调用常量对象的非const成员函数时错误的
  ```

* 在使用（调用)const成员函数的地方，告诉编译程序该成员函数不会改变对象数据成员的值

  常量对象常常用于函数的形参类型说明，当把一个对象传给函数时，为了提高参数传递的效率，并且防止函数修改实参对象，往往把形参定义为常量对象指针或常量对象引用。

  ```c++
  void f(const A *pa);
  void f(const A &a);
  ```

  ==当const成员函数放在类外定义时，则函数声明和定义的地方都要加上const==

  ```c++
  class A
  {
      ...
      void f() const;//声明
  };
  void A::f() const//定义
  {......}
  ```

  ### 2.静态成员

  ==解决同一个类的对象共享数据（数据交换等）的问题==**静态数据成员是属于类的，整个类只有一份备份，相当于类的全局变量，能够被该类的所有对象共用。**

  **常规成员**

  * 每个对象拥有独立的数据成员备份

  * 不能在确定对象之外存在

  **静态数据成员static data member**

  * 被类的所有成员所共享

  * 与类关联，而不与特定的对象关联

  * 即便类没有任何对象时，就已经存在

  * 生命期与程序相同

  1. 静态数据成员

     ==在类的声明中将数据成员指定为静态成员，只是一种声明，并不会为该成员分配内存空间，在使用之前应该对它进行定义==

     ```c++
     class A
     {
         int x,y;
         static int shared;//静态数据成员声明
       public:
         A(){x=y=0;}
         void increase_all(){x++;y++;shared++;}
         int sum_all() const{return x+y+shared;}
         ......
     }；
     int A::shared=0;//静态数据成员的定义
     ```

     静态数据成员往往要在类的外部给出它们的定义并进行初始化，==静态数据成员对于某个类的所有对象只存在一个拷贝，当通过一个对象改变了静态数据成员的值时，通过同类的其他对象可以看到这个修改==

     ==注意：①在类外定义静态数据成员时，不能加上static限定词；②在定义静态数据成员时可以指定它的初始值（第2种定义形式），若定义时没有指定初值，系统默认其初值为0。==

     静态数据成员的访问：

     *  ==通过类名访问（这种访问方式是非静态成员不具有的）：类名::静态成员名;==

     *  通过对象访问：对象名.静态成员名;

  2. 静态成员函数

     ```;
     class A
     {
         int x,y;
         static int shared;
       public:
         A(){x=y=0;}
         static void get set_shared(int i){shared=i;}
         static int get_shared(){return shared;}
         ......
     };
     int A::shared=
     ```

     静态成员函数只能访问静态成员，且静态成员函数没有隐藏的this指针参数，因为静态成员函数对静态数据成员进行操作，而非某个具体对象。访问类的静态成员的方式可以有两种

     * 通过对象访问

       ```
       A a;
       a.set_shared(10);
       ```

     * 通过类名受限访问

       ```
       A::get_shared(10);
       ```

       方式2表明，访问一个类的静态成员可以不必通过相应类的对象。实际上，类的静态成员与是否存在该类的对象没有关系

     **说明：**

     * 同普通成员函数一样，静态成员函数也可以在类内或类外定义，还可以定义成内联函数；

     * 静态函数只能访问静态成员（包括静态的数据成员和成员函数），不能访问非静态成员。 

     * 静态成员函数可以在定义类的任何对象之前被调用，非静态成员只有在定义对象后，通过对象才能访问。 

     * 在类外定义静态成员函数时，不能加上static限定词。

     使用静态成员的优点：

     * static成员的名字是在类的作用域中，因此可以避免与其他类的成员或全局对象名字冲突；

     * 可以实施封装。static成员可以是私有成员，而全局对象不可以；

     * 通过阅读程序容易看出static成员是与特定类关联，这种可见性可清晰地显示程序员的意图。

  ### 3.友元

  根据数据保护的要求，不应在一个类的外部访问该类的数据成员，private访问控制可以实现这一点，但对public数据成员的访问需要通过public成员函数进行，会导致访问效率的降低。==在c++的一个类定义中，指定某个全局函数某个类或某个其他类的某个成员函数能直接访问该类的私有和保护成员，统称为友元。

  * 友元函数

    一个类的友元函数能够直接访问该类所有成员，包括public、protected、private类型的成员。友元函数的定义形式如下

    ```c++
    class X{
    ……
    	friend  T f(…);      //声明f为X类的友元
    };
    ……
     T  f(…) { …… }      //友元不是类成员函数，定义时不能用“X::f”限定函数名
    ```

  * 友元类

    一个类可以是另一个类的友元，友元类的所有成员函数都是另一个类的友元函数，能够直接访问另一个类的所有成员（包括public、private和protected）。

    注意，友元关系是单向的，不是双向的，类B是类A的友元并不意味着类A是类B的友元，如果想让类A成为类B的友元，必须在类B中加上friend class A的声明。友元关系是不能传递的，B类是A类的友元，C类是B类的友元，但Ｃ类与A类没有友元关系。

  * 友元类成员函数

    可以指定类的某个成员函数是另一个类的友元，也就是友元成员函数。友元成员函数可以直接访问另一个类的私有成员或保护成员，而不是友元的成员函数就只能通过公有成员函数访问其他类的私有和保护成员。

  * 友元的使用注意事项:

    * 在类域中的函数原型前加上关键字**friend**，就将该函数指定为该类的友元了。关键字friend用于声明友元，它只能出现在类的声明中。

    * 友元函数**并非类的成员函数**，所以它不受public、protected、private的限定，无论将它放在public区，或者protected区，还是private区，都是完全相同的。

    * 友元**不具逆向性和传递性**。即，若A是B的友元，并不表示B是A的友元（除非特别声明）；若A是B的友元，B是C的友元，也不能代表A是C的友元（除非特别声明）。

    * 友元使编程更简洁，程序运行效率也更高，但它可以直接访问类的私有成员，破坏了类的封装性和信息隐藏。不建议多用友元。

  ### 4. 转移构造函数

  用一个即将消亡的对象去初始化另一个同类的对象时，目前的拷贝构造函数效率不高

  ```c++
  class A
  {
      char *p;
    public:
      A(char *str){p=new char[strlen(Str)+1];strcpy(p,str);}
      A (const A& x)
      {
          p=new char[strlen(x.p)+1];//申请空间
          strcpy(p,x.p);
      }
      ~A()
      {
         delete[]p;//归还空间
          p=NULL;
  	}
      ...
  };
  A f()
  {
      A t("1234");//创建局部对象t(调用构造函数)
      ....
      return t;//创建返回值对象，用即将消亡的对象t对其初始化(调用拷贝构造函数)，然后对象t消亡
  }
  int main()
  {
      ...
     ...f()...//使用函数f返回的临时对象
          ...
  }
  ```

  在函数f返回时创建一个临时的返回值对象，并调用拷贝构造函数用对象t对其初始化，，而在拷贝构造函数中要为该临时对象申请p所指向的空间，并把对象t的内容复制到该空间中，初始化完之后对象t消亡，调用析构函数归还t申请的空间。转移构造函数解决了在f中创建返回值对象时，由于对象t即将消亡，对象t申请的空间直接带到返回值对象中，避免为返回值对象申请新空间，内容复制以及归还对象t申请的空间所带来的开销。

  ```c++
  A(A&& x)//右值引用类型.要求相应的实参只能是临时对象或即将消亡的对象
  {
      p=x.p;//把参数对象x的p所指向的空间作为新对象p所指向的空间
      x.p=NULL;
  }
  
  ```

  ## 6.类的作用域

  类构成了一种特殊的作用域，称为类域。类域是指类定义时的一对花括号所括起来的范围，形式如下：

  ```c++
  class X{ //类域开始
  …
  }；//类域结束
  ```

  类域范围内的成员可以互相访问，不受成员访问控制权限的限定，类外的函数则只能访问类的公有成员。 

  ![6a64fd5ccb22f84dea8e80b6c1cc91f9.png](https://p.ananas.chaoxing.com/star3/origin/6a64fd5ccb22f84dea8e80b6c1cc91f9.png)

  ==在成员函数内部定义的变量，其作用域限于定义它的成员函数==。如果类的数据成员与某个成员函数内定义的变量同名，可用类名::数据成员名的方式访问该数据成员。在类域中可以用static、限定类的成员，static成员实际是类域范围内的全局变量或函数，由该类的所有对象共用，但不能用auto、register、extern限定类域内变量（即数据成员）的定义。

  ## 7. 对象的生存期

  * 生存期与对象的构造次序和销毁次序密切相关。

  * 局部对象和静态对象的构造次序与它们在块中的声明次序相同，即在块中先声明的就先构造，块即对象定义所在的一对{}所框定的代码区域。

  * 所有的全局对象在main之前构造，在main 结束之后销毁。

  * 对象数据成员（包括对象成员）的构造次序与其在类中的声明次序相同，而与它们在构造函数的初始化列表中的次序无关。

  * 在对象生存期结束时，具有相同生存期的对象将按与构造的相反次序销毁。

  * ==非静态对象的生存期与其作用域是一致的，而静态对象的生存期则长于其作用域，程序结束时静态对象的生存期才结束。==

  ## 8.操作符重载

* 运算符重载的概念

  * 可以重新定义大多数运算符，

    +  -  / \* % ^ & | ~ ! = < > +=** 

     **-= \*=  /= %= ^= &= |= >>**

    **>>=  <<= ==  != <= >= [ ]**

    **() new new[] delete delete[]** 

  * 不能重载某些特殊运算符，包括：类属关系运算符“.”、成员指针运算符“.*”、作用域限定符“::”、三目运算符“?:”、宏定义符号#、sizeof运算符、typeid获知一个变量的具体类型

  * 重载规则

    * 只能被重载为类成员函数的运算符：=  []  ()  ->

    * 不能改变运算符的目、优先级、结合性

    * 无隐含重载，即：定义了+，并不隐含定义+=

    * 操作数中至少一个是自定义类型

    * 程序定义的含义与运算符固有含义吻合

    * 只能重载系统已有的运算符，不能创造新运算符

* 重载方式

  * C++为类提供了默认的重载运算符

    * 赋值运算符（=）；

    * 取类对象地址的运算符（&）；

    * 成员访问运算符（如“.”和“->”）。

    这些运算符不需要重载就可以使用，但要在类中使用其他运算符，就必须明确地重载它们。

    ==类运算符重载有两种方式：一种是以非静态成员函数的方式重载，另一种是以友元函数的方式重载。==

  * 以非静态成员实现运算符重载

    以类成员形式重载的运算符参数比实际参数少一个，第1个参数是以this指针隐式传递的。 

    ```c++
    class Complex{
    double real,image;
    public:
      Complex operator+(Complex x){……}
          ……
        };
    Complex a,b,c;
    a=b+c;
    ```

     b+c调用了重载运算符+，参数b传递给了隐式参数，而+运算符函数是隐式参数的成员函数，语句“a=b+c；”与“a=b.operator+(c);”等价。静态成员函数没有this指针，所以不能将运算符重载为类的静态成员函数。

  * 以友元或普通函数实现运算符重载

    重载为普通函数或类的友元，参数个数就与运算符实际参数个数相同。形式如下： 

     ```c++
     class Complex{
      ……
        friend Complex operator+(Complex a,Complex b);
     };
      Complex operator+(Complex a,Complex b){……}  //友元定义
      Complex operator-(Complex a,Complex b){……}  //普通函数
     ```

    友元和普通函数的区别在于友元可以直接访问类的私有成员，而普通函数只能通过类的公有成员访问其私有成员。

  * 成员函数还是友元函数：

    ==**一般来说，对于双目运算符，最好将其重载为友元函数，因为这样更方便些；而对于单目运算符，则最好重载为成员函数。**==

    ①双目运算符不能重载为友元函数的：赋值运算符=；

    ②单目运算符只能重载为成员函数的：函数调用运算符()、下标运算符[]和指针->等；

    ③只能重载为友元函数的：输出运算符<<，第一个操作数一定是ostream类型；输入运算符>>；

    ④只能重载为类成员函数的：=，[ ]，()，-> 。

    注意：

      =表示的是将自身赋值为，[]表示自身第n个元素，如果被重载为友元，会出现语义上的不一致。

      一般而言，复合赋值运算符（如+=、-=、*=、/=等）通常应该重载为类成员，但并不是必须这样做（这一点与“=”不同)。对于要改变对象状态的运算符，或者与给定类型密切相关的运算符，如++（自增）、--（自减）、解引用运算符，也适宜重载为类成员函数。

      算术运算（+、*、/、-等）、相等与否的比较、关系运算、位运算等运算符具有对称性，通常允许运算符左、右两边的对象进行交换或类型转换，则适宜重载为非成员函数。

* 双目操作符重载

  * 作为成员函数重载双目操作符

    因为成员函数已经有一个隐藏的参数this，因此作为成员函数重载双目操作符时只需给出一个参数即可。

    * 声明格式

      ```c++
      class <类名>
      {
          ......
          <返回值类型> operator #(类型)；
      }；
      ```

    * 定义格式

      ```c++
      <返回值类型><类名>::operator *(<类型><参数>){......}
      ```

    * 使用格式

      ```
      <类名>a;
      <类型>b;
      a #b;
      或
      a.operator #(b)
      ```

      ```c++
      //有复数类Complex，利用运算符重载实现复数的加、减、乘、除等复数运算
      #include<iostream>
      using namespace std;
      class Complex {
      private:
          double  r, i;
      public:
      	Complex (double R=0, double I=0):r(R), i(I){ };
      	Complex operator+(Complex b);//复数加法
      	Complex operator-(Complex b);//复数减法
      	Complex operator*(Complex b);//复数乘法
      	Complex operator/(Complex b);//复数除法
      	void  display();
      };
      Complex Complex::operator +(Complex b)
      {return Complex(r+b.r,i+b.i);}
      Complex Complex::operator -(Complex b)
      {return Complex(r-b.r,i-b.i);}
      Complex Complex::operator *(Complex b){
      	Complex t;
      	t.r=r*b.r-i*b.i;
      	t.i=r*b.i+i*b.r;
      	return t;
      }
      Complex Complex::operator /(Complex b) {
      	Complex t;
      	double x;
      	x=1/(b.r*b.r+b.i*b.i);
      	t.r=x*(r*b.r+i*b.i);
      	t.i=x*(i*b.r-r*b.i);
      	return t;
      }
      void Complex::display(){
      	cout<<r;
      	if (i>0) cout<<"+";
      	if (i!=0) cout<<i<<"i"<<endl;
      }
      void main(void) {
      	Complex c1(1,2),c2(3,4),c3,c4,c5,c6;
      	c3=c1+c2;
      	c3=c1.operator+(c2);
      	c4=c1-c2;
      	c5=c1*c2;
      	c6=c1/c2;
      	c6=c1+2;
      	//c6=2+c1;
      	c1.display();
      	c2.display();
      	c3.display();
      	c4.display();
      	c5.display();
      	c6.display();
      }
      ```

      

  * 类的友元（或全局函数）实现运算符重载

    在有些情况下，只有将运算符重载为类的友元才能解决某些问题。比如，对于上述例子，假设有下面的加法运算：

    Complex a,b(2,3);

    a=b+2;  //正确

    a=2+b;  //错误

    就运算本身而言，b+2和2+b完全相同，应该具有相同的运算结果，但为什么a=b+2是正确的，而a=2+b就不行了吗？原因是，当将operator+重载为Complex类的成员函数时，运算符是“+”左边那个对象的成员函数，表达式b+2将被解释为b.operator+(2);b是一个Complex对象，而Complex类重载了operator+运算符函数，所以b.opertaor+(2)这种调用是正确的。而表达式2+b则被解释为2.operator+(b)这是错误的，2不是一个Complex对象，它没有operator+运算符函数。在这种情况下，C++也不会尝试把2转换成一个Complex对象。将operator+运算符函数重载为Complex类的友元或普通函数就能够解决这个问题。

    **作为友元或普通函数重载**

    重载二元运算符为类的友元函数时需要两个参数，其形式如下：

    ```c++
    class X{
     ……
    friend T1 operator@(T2 a,T3 b); }
    T1 operator@(T2 a,T3 b){ ……}  //友元：可直接访问a，b私有成员
    T1 operator#(T2 a,T3 b){ ……} //普通函数：只能访问a,b公有成员
    ```

    T1、T2、T3代表不同的数据类型，事实上它们常与类X相同。

    ```c++
    //对于复数类Complex，利用友元运算符重载实现复数的加法，用成员函数重载减法运算
    #include <iostream>
    using namespace std;
    class Complex {
    private:
    	double  r, i;
    public:
    	Complex (double R=0, double I=0) : r(R), i(I){ };
    	friend Complex operator+(Complex a,Complex b); //实现复数+复数
    	Complex operator-(Complex a); //实现复数-复数
    	Complex operator-(double a);  //实现复数-双精度数
    	void  display(){
    		cout<<r;
    		if (i>0) cout<<"+";
    		if (i!=0) cout<<i<<"i"<<endl;
    	}
    };
    Complex operator+(Complex a,Complex b)
    {
    	Complex t;
    	t.r=a.r+b.r;
    	t.i=a.i+b.i;
    	return t;
    }
    Complex Complex::operator-(Complex a){  return Complex(r-a.r,i-a.i);}
    Complex Complex::operator-(double a) {	return Complex(r-a,i);}
    void main(void){
    	Complex c1(1,2),c2(3,4),c3,c4,c5,c6;
    	c3=c1+c2; c3.display();
    	c3=operator+(c1,c2);
    	c3=2+c2;  c3.display();
    	c3=c2+2;  c3.display();
    	c4=c1-c2; c4.display();
        //c5=4-c1;  c5.display();   //L1 错误
    	c5=c1-4;  c5.display ();
    	c3=operator+(c1,c2);c3.display();
    	c3=operator+(2,c2);
    	c3=operator+(c2,2);
    	c4=c1.operator-(c2);
    	c5=c1.operator-(4);
    
    	c3=Complex(2,0)+c2;
    	c3=c2+Complex(2,0);
    	c5=c1-Complex(4,0);
    }
    ```

    ### 说明：

    **1、解决运算符左、右操作数据的次序交换问题**

    ①==对于不要求左值且可以交换参数次序的运算符（如+、、*、/ 等运算符），最好用非成员形式（包括友元和普通函数）的重载运算符函数实现。因为在用运算符计算表达式的值时，如果参数的类型与运算符需要的类型不匹配，这种重载方式会对参数进行隐式类型转换。==

    ②对于前面分析过的“2+c2”和“c2+2”之类的对称运算表达式，也可以直接通过友元运算符重载实现。

    **2、解决运算符左操作数据的类型转换问题**

    在调用重载的二元运算符函数时，如果第2个实参与形参的类型不匹配，C++将进行所有可能的隐式类型转换。

    对于第一个参数，就要分情况了：对于非类成员的重载运算符函数，C++编译器在参数不匹配的情况下将对第一个参数进行隐式类型转换；但不会对类成员运算符函数的第一个参数进行任何隐式类型转换。

  

### 2.单目操作符重载

* 作为成员函数重载单目操作符

  因为成员函数已经有一个隐藏的参数this，因此作为成员函数重载双目操作符时只需给出一个参数即可。

  * 声明格式

    ```c++
    class <类名>
    {
        ......
        <返回值类型> operator #()；
    }；
    ```

  * 定义格式

    ```c++
    <返回值类型><类名>::operator #(){......}
    ```

  * 使用格式

    ```
    <类名>a;
    #a;
    或
    a.operator #()
    ```

    从形式上看，作为类成员函数重载的一元运算符没有参数，但实际上它包含了一个隐含参数，即调用对象的**this**指针。

    像++、--这样能够实现连续自增、自减的运算符，其重载函数应该返回对象的引用。否则，就不能实现对象的连续运算。

    ```c++
    //设计一个时间类Time，它能够完成秒钟的自增运算
    #include<iostream>
    using namespace std;
    class Time{
    private:
    	int hour,minute,second;
    public:
    	Time(int h,int m,int s);
    	Time operator++();
    	void display();
    };
    Time::Time(int h,int m,int s):hour(h),minute(m),second(s) {
    	if(hour>=24) hour=0;//若初始小时超过24，重置为0
    	if(minute>=60) minute=0;//若初始分钟超过60，重置为0
    	if(second>=60) second=0;//若初始秒钟超过60，重置为0
    }
    Time Time::operator ++(){
    	++second;
    	if(second>=60) {
    		second=0;
    		++minute;
    		if(minute>=60){
    			minute=0;
    			++hour;
    			if(hour>=24)  hour=0;
    		}
    	}
    	return *this;
    }
    void Time::display(){
    	cout<<hour<<":"<<minute<<":"<<second<<endl;
    }
    void main(){
    	Time t1(23,59,59);
    	t1.display();
    	++t1;           //隐式调用方式
    	t1.display(); 
    	t1.operator++();//显式调用方式
    	t1.display();
    }
    
    ```

* 作为成员函数重载单目操作符

  因为成员函数已经有一个隐藏的参数this，因此作为成员函数重载双目操作符时只需给出一个参数即可。

  * 声明格式

    ```c++
     <返回值类型> operator #(<类型><参数>){......}
    ```

  * 使用格式

    ```
    <类名>a;
    #a;
    或a
    operator #(a)
    ```

    ```c++
    //设计一个时间类Time，它能够完成秒钟的自增运算,
    #include<iostream>
    using namespace std;
    class Time{
    private:
    	int hour,minute,second;
    public:
    	Time(int h,int m,int s);
    	friend Time operator++(Time &t);
    	void display();
    };
    Time::Time(int h,int m,int s):hour(h),minute(m),second(s) {
    	if(hour>=24) hour=0;//若初始小时超过24，重置为0
    	if(minute>=60) minute=0;//若初始分钟超过60，重置为0
    	if(second>=60) second=0;//若初始秒钟超过60，重置为0
    }
    Time operator ++(Time &t) {
         ++t.second;
          if(t.second>=60){
          t.second=0;
         ++t.minute;
          if(t.minute>=60){
                   t.minute=0;
                  ++t.hour;
                   if(t.hour>=24)  t.hour=0;
          }
          }
        return t;
     }
    void Time::display(){
    	cout<<hour<<":"<<minute<<":"<<second<<endl;
    }
    void main(){
    		Time t1(23,59,59);
    		t1.display();
    		++ t1;                       		//隐式调用方式
    		t1.display();
    		operator++(t1);              	 	//显式调用方式
    		t1.display();
    
    }
    
    ```

    

  * 运算符++和--的重载

    **前缀：**

    operator -- ();

    operator -- (X & x);

    **后缀：**加入一个无用的类型参数，表示后缀

    operator -- (int);

    operator -- (X & x, int);

    从上面的形式可以看出，不管是被重载为类的成员函数，还是被重载为类的友元函数，后缀形式的一元运算符都比前缀形式的一元运算符多一个形式参数。这个形式参数的唯一作用是告知c++编译器该运算符是后缀运算符，参数的值没有任何实际意义，所以它常常只有一个类型名，连形式参数的名字也不需要。

    ```c++
    //设计一个计数器counter，用类成员重载自增运算符实现计数器的自增，用友元重载实现计数器的自减
    #include<iostream>
    using namespace std;
    class Counter{
    private:
    	int n;
    public:
    	Counter(int i=0){n=i;}
    	Counter operator++();
    	Counter operator++(int);
    	friend Counter operator--(Counter &c);
    	friend Counter operator--(Counter &c,int);
    	void display();
    };
    Counter Counter::operator++(){
    		++n;
    		return *this;
    }
    Counter Counter::operator++(int){
    		n++;
    		return *this;
    }
    Counter operator--(Counter &c){
    		--c.n;
    		return c;
    }
    Counter operator--(Counter &c,int){
    		c.n--;
    		return c;
    }
    
    void Counter::display(){
    		cout<<"counter number = "<<n<<endl;
    }
    void main(){
    		Counter a;
    		++a;         //调用Counter::operator++()
    		a.display();
    		a++;         //调用Counter::operator++(int)
    		a.display();
    		--a;         //调用operator--(Counter &c)
    		a.display();
    		a--;         //调用operator--(Counter &c,int)
    		a.display();
    }
    ```

* 输出运算符重载

  输出运算符**<<**也称为插入运算符，通过输出运算符<<的重载可以实现用户自定义数据类型的输出。重载运算符<<的常见格式如下：

  ```c++
  ostream &operator<<(ostream &os,classType object) {
   ……
  os<< …  //输出对象的实际成员数据 
  return os; //返回ostream对象
  }
  ```

* 输入运算符重载

  输入运算符>>也称为提取运算符，用于输入数据。通过输入运算符>>的重载，就能够用它输 入用户自定义的数据类型。

  其重载形式如下：

  ```c++
  istream &operator>>(istream &is,class_name &object) {
  ……
  is>> …  //输入对象object的实际成员数据 
  return is;  //返回istream对象
  }  
  ```

   输入/输出重载的第一个参数必须是ostream/istream类对象的引用，所以它不能被重载为类的成员函数，因为要是重载为类的成员函数时，其第一个参数必定是通过this指针传递的当前对象，而不是ostream类对象的引用。因此，输入输出运算符常被重载为类的友元函数。

  ```c++
  //有一销售人员类Sales，其数据成员有姓名name，身份证号id，年龄age。重载输入/输出运算符实现对Sales类数据成员的输入和输出
  #include<iostream>
  #include<string>
  using namespace std;
  class Sales{
  private:
  		string name,id;
  		int age;
  public:
  		Sales(string Name,string ID,int Age);
  		friend ostream &operator<<(ostream &os,Sales &s);
  		//重载输出运算符
  		friend istream &operator>>(istream &is,Sales &s);
  		//重载输入运算符
  };
  
  Sales::Sales(string Name,string ID,int Age) {
  		name=Name;
  		id=ID;
  		age=Age;
  }
  ostream& operator<<(ostream &os,Sales &s) {
  		os<<s.name<<"\t";             //输出姓名
  		os<<s.id<<"\t";               //输出身份证号
  		os<<s.age<<endl;              //输出年龄
  		return os;
  }
  istream &operator>>(istream &is,Sales &s) {
  		cout<<"输入雇员的姓名，身份证号，年龄"<<endl; 
  		//显示输入提示信息
  		is>>s.name>>s.id>>s.age;                      
  		//数据成员数据输入
  		return is;
  }
  void main(){
  		Sales s1("黄梅","214198012111711",40);  //L1
  		cout<<s1;                             	//L2
  		cout<<endl;                             //L3
  		cin>>s1;                              	//L4
  		cout<<s1;                             	//L5
  }
  ```
